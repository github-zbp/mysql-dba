2-1 范式 
什么是范式？ 范式是数据库规范化的一个手段，是数据库设计中的一系列原理和技术，用于减少数据库中的数据冗余，并增进数据的一致性。

反范式是试图通过增加冗余数据或通过分组数据来优化数据库读取性能的过程。在某些情况下，反范式是解决数据库性能 和可伸缩性的极佳策略
反范式的作用是减少多表连接，可以更好地利用索引进行筛选和排序，对于一些查询操作可以提高性能

那么反范式具体是怎么提高查询的性能的呢？下面是具体的例子：

1 论坛的消息表forum_message包括如下字段：msg_id、from_uid、to_uid、subject、message、post_time。由于表中只存储了 会员id的信息，因此如果要显示发送给某个用户（以to_uid标识）的完整消息，还需要用from_uid去连接会员表，获取会员的姓
名，在高并发的情况下，这样做可能会带来性能问题，常用的解决方案是增加1个冗余字段from_uname以避免JOIN。

2 反范式可以更好地利用索引进行筛选和排序，如上一个例子1）中，如果需要按照uname对消息进行排序，则需要连接 会员表，然后按照uname进行排序，这样的代价比较高，增加冗余列uname，并在其上创建索引，就可以利用索引排序很快地返 回结果。

3 一些统计操作，比如COUNT、SUM、MAX、MIN等操作，如果计算耗费的资源比较多，可以考虑增加冗余的统计信 息，或者增加额外的字段，或者增加额外的表，比如论坛的发帖统计，用户在线人数等。
例如对于发帖统计，需要统计最近24小时的发帖数量，我们可以每个小时插入一条统计数据到统计表，这样就可以统计 最近24小时的数据了，虽然这样做不够准确，但用户一般不会介意这种数据的不准确性。如果需要更精确的统计，可以在前23 个小时使用统计值，最近1个小时使用实际值即可

4 如果某个用户表的字段比较多（如uid、uname、upass、email、address、qq、msn……），数据量很大，超过亿级别，那 么为了方便扩展，我们将把数据分片到多个表中，例如，我们对uid这个整型字段进行求模运算，把求模运算结果一样的uid存放 到同一张分表中。这时，用户需要以uname登录，查询uid，以便到分表中去查询数据。因此可以增加一个冗余表，只存储uname 和uid的映射关系。由于这个冗余表仅有两个列，因此虽然数据量很大，但完全可以放在一张表内，也方便加载到内存中进行访 问

从上面四个例子,总结出几点:

1. 什么情况可以在一张表里面增加冗余字段: 一个是当你要查的字段在两个表里面,为此你要多表联查,而多表联查的性能又低的时候;一个是你要查的字段只在一个表里面,但是要根据排序或者分组的字段在另一个表里面,为了用这个字段排序要多表联查,此时就可以将这个字段也加到前面那个表里面，当然这个字段还要添加索引，否则变成文件排序性能一样很差。

2.如果一些统计量会被多次查询，可以将他放在缓存或者单独放在一张表中。


2-2 权限和安全

MySQL访问权限系统

MySQL权限系统的主要功能是证实连接到一台给定主机的用户，并且赋予该用户在数据库上的各种权限，一般生产环境中的程序账号只需要SELECT、INSERT、UPDATE和DELETE权限即可

MySQL将验证用户的3项 信息：用户名、密码、主机来源。

权限可以分为两类：系统权限和对象选项。 系统权限允许执行一些特定的功能，如关闭数据库、终止进程、显示数据库列表、查看当前执行的查询等。对象权限是指 对一些特殊的对象（表、列、视图、数据库）的访问权限，例如是否允许访问某张表，是否允许在某个库中创建表。

一般不允许直接更改MySQL的权限表，而是通过GRANT和REVOKE语句进行权限的赋予和收回，这也是更安全可靠的办法

GRANT和REVOKE语句允许系统管理员创建MySQL用户账户、授予权限和撤销权限。授予的权限可以分为多个级别：服务器级别（全局）、数据库级别、表级别、列级别、子程序级别。撤销权限即回收已经存在的权限。

GRANT [privileges] ON [objects] TO [user] 
GRANT [privileges] ON [objects] TO [user] IDENTIFIED BY [password] 
REVOKE [privileges] ON [objects] FROM [user]

MySQL为有SUPER权限的用户专门保留了一个额外的连接，因此即使是所有的普通连接都被占用，MySQLroot用户仍可以登录并检查服务器的活动。

如果想要限制单个账号允许的连接数量，可以通过设置max_user_connections变量来完成。

当在GRANT语句中指定数据库名称时，允许使用“_”和“%”通配符。这意味着，如果想要使用“_”字符作为一个数据库名称的一部分，则应该在GRANT语句中指定它为“\_”，例如，“GRANT…ON‘foo\_bar’.*TO…。”

SHOW TABLES命令不会显示用户没有权限访问的表。







常用的权限 

SHOW PRIVILEGES命令可以显示MySQL所支持的权限，如下是一些常用的权限。

SELECT、INSERT、UPDATE和DELETE权限允许用户在一个数据库现有的表上实施读取、插入、更新和删除记录的操作。这也是一般程序账号所需要的权限。 

SHOW VIEW权限允许用户查看已经创建了的视图。 

ALTER权限允许用户使用ALTERTABLE命令来修改现有数据表的结构。 

CREATE和DROP权限允许用户创建新的数据库和表，或者删除现存的数据库和表。生产环境中一般不赋予程序账号DROP的权限。
GRANT权限允许用户把自己拥有的权限授予其他的用户。 
FILE权限允许被授予该权限的用户都能读或写MySQL服务器能读写的任何文件。

SHUTDOWN权限允许用户使用SHUTDOWN命令关掉服务器。可以创建一个用户专门用来关闭服务器。 

PROCESS权限允许用户使用PROCESSLIST命令显示在服务器内执行的进程的信息；使用KILL命令终止服务器进程。用户总是能显示或终止自己的进程，但是，显示或终止其他用户启动的进程则需要PROCESS权限。一些监控工具需要PROCESS权 限查看正在执行的命令。


显示某个用户的权限的命令如下
SHOW GRANTS FOR username@'ip_range';

如 show grants for root@localhost;

show grants 只能查看一个用户的权限

show grants for zbp@127.0.0.1

如果想查看所有用户可以
use mysql 
select host,user from user;

不过这个只能看到哪个用户的那个ip可以连接该台服务器,看不到权限


赋予某个用户对库db1进行SELECT、INSERT、UPDATE和DELETE的权限的命令如下。
GRANT SELECT,INSERT,UPDATE,DELETE ON db1.* TO username@'10.%' IDENTIFIED BY 'your_password';

如 
grant all privileges on art1.* to zbp@"127.0.0.1" identified by "123456";    # 赋予zbp用户在本机上对art1所有表的所有权限; on *.* 表示所有库的所有表； 如果允许zbp在所有的ip上远程连接该数据库则 zbp@"%"

PS 在mysql中127.0.0.1和localhost不同,mysql -uroot -p 默认的主机是 localhost ; 所以如果想用刚刚的zbp登陆就要 mysql -h127.0.0.1 -uzbp -p 才可以

如果相对赋予权限的用户修改密码,只需重新赋予一次权限即可。

如需撤销权限可以这样:
revoke all privileges on art1.* from zbp@127.0.0.1;

一定要制定好要撤销的权限,库表,用户和主机名,缺一不可,最好赋予权限的时候怎么写,撤销的时候原封不动的复制。如果忘记了可以用 show grants 命令查看

当撤消了zbp用户的权限之后,在查看zbp的权限
show grants for zbp@127.0.0.1
+-----------------------------------------+
| Grants for zbp@127.0.0.1                |
+-----------------------------------------+
| GRANT USAGE ON *.* TO 'zbp'@'127.0.0.1' |
+-----------------------------------------+

发现还有一个USAGE权限,这是zbp的登陆权限还留着。

revoke usage on *.* from zbp@127.0.0.1 ;

发现还是没法删除这个权限。其实删掉这个用户即可

drop user zbp@127.0.0.1;    # 删除用户除了要指定用户名还要指定ip,而且ip在赋予权限的时候怎么设,删的时候就要怎么写


下面是具体的mysql远程连接的例子:
两台服务器: 192.0.0.10     192.0.0.11
现在192.0.0.11要远程连接到192.0.0.10

在 192.0.0.10设置权限:
grant all privileges on *.* to zbp@"192.0.0.11" identified by "123456";   # 可以执行flush privileges 刷新一下权限

然后在192.0.0.11就可以连接 192.0.0.10了:
mysql -h 192.0.0.10 -u zbp -p 123456

那么接下来就是说一下一系列无法远程连接的状况:
A Can't connect to MySQL server on 'xxx' (111) 
这种情况的话需要在被连接的服务器 192.0.0.10 的数据库配置文件 /etc/my.cnf 找到 bind-address = 127.0.0.1 在他后面加一个ip 192.0.0.11允许这台服务器连接

bind-address = 127.0.0.1 192.0.0.11

======================================================================
PS:如果不知道自己的mysql配置文件在哪里可以这样:                     |
which mysqld     #得到mysqld命令的绝对路径,我这里是/usr/sbin/mysqld |
/usr/sbin/mysqld --verbose --help |grep -A 1 'Default options'       |
就会显示mysql的配置文件位置,会显示多个,要一个个找                   |
======================================================================

如果在/etc/my.cnf找不到这句,可能在my.cnf所引入的其他配置文件中里,例如 my.cnf中有一句!includedir /etc/my.cnf.d ,意思是引入这个目录下所有的配置文件,所以可以在这个目录下的配置文件下找找看。如果找不到，那么可以直接自己在my.cnf加一句bind-address

B Can't connect to MySQL server on 'xxx' (110)
110的情况是防火墙的原因,此时在 192.0.0.11 和 192.0.0.10 都关掉防火墙,然后重启一下mysql服务

systemctl stop firewalld

如果还是不行,那么很可能是因为你的服务器是云服务器,此时要登陆云服务器后台开启3306端口对外开放才行。
可以通过 telnet 远程ip 3306 来试试能不能连上对方的服务器;或者使用ping工具


最后如果被连接的服务器撤消了zbp@192.0.0.11的权限之后,192.0.0.11依旧可以通过zbp用户连接到192.0.0.10的mysql服务器,但是权限已经没了,无法查看或者操作远程服务器的表和数据。可以在192.0.0.10删掉zbp用户,这样.11就无法连接到.10了

2-3 慢日志查询
如果开启了mysql的慢日志,那么该日志会记录下所有mysql认为效率低的sql语句,我们可以通过查看慢日志获取这些语句并进行优化

MySQL的慢查询日志比较粗略，主要是基于以下3项基本的信息。 
Query_time：查询耗时。 

Rows_examined：检查了多少条记录。 

Rows_sent：返回了多少行记录（结果集）。 以上3个值可以大致衡量一条查询的成本。 如果检查了大量记录，而只返回很小的结果集，则往往意味着查询质量不佳。

其他信息包括如下几点。 
Time：执行SQL的开始时间。 
Lock_time：等待tablelock的时间，注意InnoDB的行锁等待是不会反应在这里的。 
User@Host：执行查询的用户和客户端IP。

可以使用mysqldumpslow命令获得慢查询 日志摘要来处理慢查询日志，或者使用更好的第三方工具pt-query-digest。，慢查询日志里的慢查询不一定就是不良SQL，还可能是受其他的查询影响，或者受系统资源限制所导致的慢查询。 比如下面的例子，会话被阻塞了，实际上是一个行锁等待50s超时，然后记录到了慢查询日志里。

A 查看是否开启慢日志：

MariaDB [(none)]> show variables like "%query_log%";
+---------------------+-------------------------+
| Variable_name       | Value                   |
+---------------------+-------------------------+
| slow_query_log      | OFF                     |
| slow_query_log_file | VM_0_13_centos-slow.log |       #   这个是慢日志保存的路径
+---------------------+-------------------------+

发现没有打开

如果配置文件或启动参数没有给出file_name值，慢查询日志将默认命名为“主机名-slow.log”，如果给出了文件名，但不是绝对路径名，文件则写入数据目录。

像这里,慢日志就是写入数据目录

我们可以在MySQL客户端下使用命令“SHOW VARIABLES LIKE'%query_time%'”查看全局变量long_query_time。所有执行时间超过long_query_time秒的SQL语句都会被记录到慢查询日志里。

建议将这个时间设为1秒

如何开启慢日志并设置保存路径和超时时间:
在配置文件的 [mysqld] 下添加下面几句:

slow_query_log = 1
slow_query_log_file = /tmp/mysql-slow.log
long_query_time = 1

即可

可能不是直接在my.cnf 中添加,而是在其引入的其他配置文件中才能找到[mysqld]

然后重启一下mysql服务


B 分析慢查询日志

如果慢查询日志内容太多,看文件是很难看出东西的,可以使用mysqldumpslow或者pt-query-digest工具
    
mysqldumpslow:

mysqldumpslow -t10 绝对路径    # 获取访问时长最长的10条语句,并存到指定路径中
mysqldumpslow -s c -t10 绝对路径  # 访问次数最多的10条语句
mysqldumpslow -s r -t10 绝对路径  # 访问条数最多的10条


pt-query-digest:

wget www.percona.com/get/pt-query-digest chmod u+x pt-query-digest    # 下载pt-query-digest命令
chmod u+x pt-query-digest

基本命令格式
pt-query-digest [options] [files] [dsn]

常见用法:假设慢日志路径为 /tmp/mysql-slow.log
pt-query-digest /tmp/mysql-slow.log > slow.rtf      #直接分析慢查询
pt-query-digest --since 1800s /tmp/mysql-slow > slow.rtf   #分析半小时内的慢查询
pt-query-digest --since '2020-01-01 00:00:00' --until '2020-01-02 00:00:00' /tmp/mysql-slow > slow.rtf    #分析指定范围内时间的慢查询
pt-query-digest --limit 95%:20 /tmp/mysql-slow > slow.rtf    #显示95%的最差查询或者20个最差查询

相应参数解释: 
Exectime：执行时间。 
Lock time：表锁的时间。 
Rows sent：返回的结果集记录数。 
Rowsexamine：实际扫描的记录数。 
Query size：应用和数据库交互的查询文本大小。 
Rank：所有查询日志分析完毕后，此查询的排序。 
Query ID：查询的标识字符串。 
Responsetime：总的响应时间，以及总占比。一般小于5%可以不用关注。 
Calls：查询被调用执行的次数。 
R/Call：每次执行的平均响应时间。 
Apdx：应用程序的性能指数得分。（Apdex响应的时间越长，得分越低。） 
V/M：响应时间的方差均值比（变异数对平均数比，变异系数）。可说明样本的分散程度，这个值越大，往往是越值得考 虑优化的对象。 
Item：查询的简单显示，包括查询的类型和所涉及的表。



当然该命令也可以用于分析mysql二进制日志文件,注意,二进制日志不是mysql服务的日志,二进制日志一般放在数据目录,可以通过show master status查看是否开启二进制日志
mysqlbinlog mysql-bin.012639 > /tmp/012639.log   # 将二进制文件转为文本格式
pt-query-digest --type binlog /tmp/012639.log > binlog.rtf

对于以上分析命令，同样可以加上参数筛选信息，如“--since”、“--until”。





2-4 应用程序性能管理（APM）
影响服务性能的主要因素，从大到小大致是：架构和设计、应用程序、硬件、Web服务器、数据库、操作系统。通过性能分析工具，我们可以知道自己的程序主要耗时在哪里，从而进行专门的优化。

性能有两组指标：
一个是 应用程序终端用户的性能体验，一个很好的例子是高峰时刻的平均响应时间   # 响应时间
一个是 计算资源是否有足够的容量来支持给定的负载                              # 服务器是否会崩掉


以下是创建索引的一些基本指导原则。 
1）不必为小表创建索引。在内存中查询该表会比存储额外的索引结构更加有效。 
2）为检索数据时大量使用的列增加二级索引。 
3）为经常有如下情况的列添加二级索引。 
查询或连接条件 
ORDERBY 
GROUP BY 
其他操作（如UNION或DISTINCT） 
4）考虑是否可以用覆盖索引（covering index）。 
5）如果查询将检索表中的大部分记录（例如25%），即使表很大，也不创建索引。这时候，查询整表可能比用索引查询更有效。
6）避免为由长字符串组成的列创建索引。


2-5 mysql数据导入导出
mysqldump之前只说过一些简单的使用mysqldump导出的命令，这里做出补充：

mysqldump --all-databases --add-drop-database > db.sql  #导出所有数据库

mysql db_name < db_name.sql     # 使用mysql命令导入数据库；转储文件（dump文件）里面一般指定了set names utf8，所以我们在导入的时候不再需要指定特殊的字符集。 

如果想指定其他字符集可以这样
mysql --default-character-set=gbk db_name < db.sql      # --default-character-set的意思是，客户端和连接都默认使用charset_name字符集

我们知道，数据库是一个多用户访问系统，因此需要一种机制来确保当多个用户同时读取和更新数据时，数据不会被破坏或失效，锁就是这样的一种并发控制技术。当一个用户需要修改数据库中的记录时，首先要获取锁，只有这样该用户在锁的持有期间，其他用户就不能对这些记录进行修改了。

MySQL Server级别的锁大致有如下两种。 （1）Tablelocks（表锁）（2）Globallocks（全局锁）

MyISAM的表锁
MySQL支持对MyISAM和MEMORY表进行表级锁。
如果你在一个表上有很多更新，那么SELECT语句将等待直到没有更多的更新操作为止。
对于MyISAM引擎的表，如果INSERT语句不会发生冲突，则可以在其他客户正在读取MyISAM表的时候插入行。

如果一个客户发出了长时间运行的查询（SELECT），而此时，另一个客户想要对同一个表进行更新（UPDATE），那么该客户必须等待直到SELECT完成。如果此时还有一个客户对同一个表也发出了另一个SELECT语句，因为UPDATE比SELECT的优先级高，那么该SELECT语句将会等待直到UPDATE完成，并且它们都要等待第1个SELECT完成。性能问题往往发生在这个步骤。


InnoDB的行锁
数据库的锁定技术往往是基于索引来实现的，InnoDB也不例外。如果我们的SQL语句里面没有利用到索引，那么InnoDB将会执行一个全表扫描，锁定所有的行（不是表锁）。 锁过多的行，增加了锁的竞争，降低了并发率，所以建立索引是很重要的，InnoDB需要索引来过滤（在存储引擎层中）掉那些不需要访问的行

行级锁定的优点如下。 
当在很多线程中访问不同的行时只存在少量锁定冲突。 
回滚时只有少量的更改。 
可以长时间锁定单一的行。

由于myisam是表锁,而innodb是行锁,所以从高并发处理上来说,应该优先选择innodb,而显示开发中,基本上都是用的innodb,很少有人用myisam


MVCC简要介绍
单纯靠行级别的锁，是不可能实现好的并发性的，MySQL InnoDB还需要配合MVCC（MultiversionConcurrencyControl）技术来提供高并发访问。在很多情况下MVCC可以不需要使用锁，即可实现更新数据时的无阻塞读。

死锁
死锁是指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法 进行下去。

尽量按照主键/索引去查找记录，范围查找增加了锁冲突的可能性，也不要利用数据库做一些额外的计算工作。比如有些读者会用到“SELECT…WHERE…ORDERBYRAND();”这样的语句，由于类似这样的语句用不到索引，因此将导致整个表的数 据都被锁住。
优化SQL和表设计，减少同时占用太多资源的情况。比如说，减少连接的表，将复杂SQL分解为多个简单的SQL。

2-6 临时表

临时表指的是CREATE TEMPORARYTABLE命令创建的临时的表，临时表只对当前连接可见，对其他连接不可见，结束连接或中断，数据表（数据）将丢失。也就是说，在短连接的情况下，断开连接后，这个表就自动删除了。如果是长连接的话， 则需要自己先初始化下表。 
我们常使用临时表来存储一些中间结果集，如果需要执行一个很耗资源的查询或需要多次操作大表，那么把中间结果或小的子集放到一个临时表里，可能会有助于加速查询。

创建了临时表之后，如果运行SHOW TABLES、SHOW OPEN TABLES、SHOW TABLE STATUS命令及在INFORMATION_SCHEMA库中都将看不到临时表，这不是Bug，而是设计就是如此。

MySQL临时表也有一些限制。比如不能用RENAME来重命名一个临时表，可以用ALTERTABLE来代替。比如，在同一个查询语句中，你只能查找一次临时表。临时表的详细使用方法和相关限制请参考官方文档。

临时表的创建:
CREATE TEMPORARY TABLE tmp_a AS SELECT * FROM t where a=1;

查询一张临时表的数据
select * from tmp_a;

注意,如果t表的字段是有主键和索引的话,临时表tmp_a 是不会保留这些主键和索引,因为临时表没有索引。索引如果在临时表中进行条件查询可能还不如在原表中进行查询。


下面是我自己的话:
有这么一种情况,做一个查询,第一次查很慢,第二次查很快;我以为是因为查询缓存;但是关闭了缓存之后依旧第二次很快,其实是因为在多表联查中mysql自动生成了临时表,第一次查的时候生成这个临时表会花比较长的时间,因为可能是全表扫描,第二次查的时候,这个临时表已经存在了,此时就会直接在这个临时表的基础上去查,所以会很快。

为了证实是临时表的原因，我关闭了客户端，再打开再查，发现第一次又变的很慢，第二次查很快。这是因为临时表在断开连接后自动删除。而如果是查询缓存是不会因为关闭客户端而消失



2-7 分区
用户所选择的、实现数据分割的规则被称为分区函数，在MySQL中它可以是模数，或者是简单地匹配一个连续的数值区间或数值列表，或者是一个内部HASH函数，或者是一个线性HASH函数

如下命令将确定MySQL是否支持分区。
SHOW VARIABLES LIKE '%partition%';

+---------------------------------------+-------+
| Variable_name                         | Value |
+---------------------------------------+-------+
| have_partitioning                     | YES   |
| innodb_adaptive_hash_index_partitions | 1     |
+---------------------------------------+-------+

有如下的一些分区类型，RANGE分区、LIST分区、HASH分区、KEY分区和子分区;常用的存储引擎，如 InnoDB、MyISAM、MEMORY都支持分区表

RANGE分区的表是通过如下这种方式进行分区的，基于一个连续区间的列值，把多行分配给分区，例如某个时间段的值属于某个分区，某个数值范围的值应该属于某个分区。

MySQL中的LIST分区在很多方面都类似于RANGE分区。和按照RANGE进行分区的方式一样，每个分区都必须明确定义。它们的主要区别在于，LIST分区中每个分区的定义和选择是基于值列表的，而RANGE分区是从属于一个连续区间值的集合的。

HASH分区是基于用户定义的表达式的返回值选择分区。它主要用来确保数据在预先确定了数目的分区中是平均分布的。 
在RANGE分区和LIST分区中，必须明确指定一个给定的列值或列值集合应该保存在哪个分区中；
而在HASH分区中，MySQL将 自动完成这些工作，你所要做的只是为将要被散列的列值指定一个列值或表达式，以及指定被分区的表将要被分割成的分区数量。

按照KEY进行分区类似于按照HASH进行分区，除了HASH分区使用的是用户自定义的表达式，而KEY分区的散列函数是由 MySQL服务器提供的。 子分区是分区表中每个分区的再次分割

下面是示例


分区的优缺点：
分区包括如下一些优点。 与单个磁盘或文件系统分区相比，可以存储更多的数据。表分区物理上被存储为单独的表（虽然我们在查询的时候，看上去所有的分区还是在一张表上，但实际上，这些分区是单独放在一个文件上的），所以可以把分区存储到不同的磁盘或文件系统中。在现实生产环境中，这样使用还是比较少见的。选择分区表更常见的是基于业务的需要，是否能够更高 效地查询数据和维护数据。 

对于那些已经失去了保存意义的数据，通常可以通过删除与那些数据有关的分区，很容易地删除掉那些数据。 

一些查询可以得到极大的优化，这主要是借助于满足一个给定WHERE语句的数据可以只保存在一个或多个分区内，这样在查找时就不用再查找剩余的其他分区了，这样扫描的数据量少了，性能自然提升。

MySQL的分区表不像Oracle那么灵活和成熟可靠，也不像Oracle那样可以有全局的索引，MySQL的索引对于每个表来说都是单独的。这样如果有跨越多个分区的查找，那么效率可能就会有问题。

那么下面是一些使用分区的建议（什么情况下适合使用分区）：
1）只有大表才可能需要分区，几百万笔记录的表并不算大，对于一些高配置的数据库主机，几千万甚至上亿条数据的表 也不算大。 
2）分区数不能过多，很难想象大于500的分区数。 
3）查询的时候，不要跨越多个分区，建议最多跨越1~2个分区。 
4）索引的列应该是分区的列，或者有其他条件限制的分区，否则访问所有分区上面的索引进行查找，开销会比较大。

写下来，我自己的关于分区的想法是这样的：
首先，数据量不超过百万的分区没有意义，因为数据量少的情况下，不分区也能有不错的性能；再者，如果分区后你的查询语句所涉及到要扫描的分区有多个的话也不建议，跨多分区查询会降低性能。

接下来就我个人经历，说一下，使用分区帮我解决的一个问题：
有一个arts表,这个表里面有80万+的数据,有字段is_send表示是否发送,值为0或1，有tid字段表示文章的分类; 
有一个表type,这个表是分类表,与arts表关联;

现在我想查询每个分类下没有发送的文章的数量:
select sql_no_cache t.name,count(*) from arts a join type t on a.tid=t.id where is_send=0 group by t.id;

现在如果发送了和未发送的文章都有40万条;此时执行上面的sql由于有where is_send=0他会全表扫描,用时大概9秒(如果去掉is_send=0则由于group by 的字段是索引字段,所以explain的type显示的是index,使用了索引,此时大概用1秒不到)

现在我们以is_send字段进行list分区,但是由于分区字段要求必须是主键或者是复合主键中的一部分,所以我们还要对主键做出调整
alter table arts id int unsigned;    # 干掉id的自增
alter table arts drop primary key;   # 干掉id的主键
alter table arts add primary (id,is_send)    #创建联合主键
alter table arts id int unsigned auto_increment;   #为id加回自增

#创建分区,is_send只有两个值 0,1,把is_send为0的数据放到分区is_send0;为1的数据放到分区is_send1
alter table arts partition list(is_send)(
    partition is_send0 values (0),
    partition is_send1 values (1)
);

# PS list分区的值中必须包含分区字段所有的值,比如如果is_send的值有0,1,2,那么还要加一条partition is_send1 values (2) 否则会报错

完了之后,我们再一次执行:
select sql_no_cache t.name,count(*) from arts a join type t on a.tid=t.id where is_send=0 group by t.id;

发现只用了4秒多,这是因为mysql会根据where条件自动找到is_send=0的分区,所以他会对is_send0分区进行全表扫描。但是按理说不应该是使用索引tid分组了吗,为什么会是全表扫描。原因是，当使用了分区后，除了非分区字段之外，其他的索引字段都失效。

所以也就意味着，当数据越来越多，执行这条sql的时间也会越长。用explain分析一下：
explain partitions select sql_no_cache t.name,count(*) from arts a right join type t on a.tid=t.id where is_send=0 group by a.tid;
+------+-------------+-------+------------+--------+---------------+---------+---------+-----------+--------+----------------------------------------------+
| id   | select_type | table | partitions | type   | possible_keys | key     | key_len | ref       | rows   | Extra                                        |
+------+-------------+-------+------------+--------+---------------+---------+---------+-----------+--------+----------------------------------------------+
|    1 | SIMPLE      | a     | is_send0   | ALL    | tid           | NULL    | NULL    | NULL      | 181094 | Using where; Using temporary; Using filesort |
|    1 | SIMPLE      | t     | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | art.a.tid |      1 |                                              |
+------+-------------+-------+------------+--------+---------------+---------+---------+-----------+--------+----------------------------------------------+

partitions为is_send0;type为ALL(全表扫描)

但是如果去掉where is_send=0;
explain partitions select sql_no_cache t.name,count(*) from arts a right join type t on a.tid=t.id group by a.tid;
她就又变成了使用索引,大概只用了0.9秒,partition显示为is_send0,is_send1


2-8 视图 
创建一个视图
create view 视图名 as select 字段 from 表 [条件,排序等];

注意视图（VIEW）并不会保存任何数据，查询视图返回的结果都是来自于基表存储的数据,所以视图一般不会用来提升性能，而是用来简化部分开发，进行权限限制。

表和视图将共享数据库中相同的名称空间，因此，数据库不能包含具有相同名称的表和视图。视图必须具有唯一的列名，不得有重复，就像基表那样。
默认情况下，由SELECT语句检索的列名将用作视图列名。

可使用多种SELECT语句创建视图。视图能够引用基表或其他视图，还能使用联合、UNION和子查询。 视图可以简化一些操作，比如隐藏基表的复杂性，进行一些安全控制（基于列的权限控制），但如果使用不当，很可能会带来性能问题。

对于包含视图的SQL，优化器进行优化的机制有两种：MERGE和TEMPTABLE。 TEMPTABLE：创建一个临时表，把视图的结果集放到临时表中，然后SQL操作这个临时表。 
MERGE：重写SQL，合并视图的SQL，这种方法更智能。

例如，新建一个视图test.v。 
CREATE VIEW test.v AS SELECT * FROM t where a=1;
 
对于视图的查询语句： 
select a,b,c from test.v where b=2; 

第一种临时表的方式类似如下语句。 
CREATE TEMPORARY TABLE TMP_a AS SELECT * FROM t where a=1; 
select * from TMP_a where b=2; 

这种方式必须先查出所有视图的数据（即对临时表全表扫描,因为临时表上没有索引），然后才能基于这个视图的数据进行查找。显然可能会有性能问题。

而用第二种方式，优化后的SQL类似如下语句。 SELECT * FROM t where a=1 and b=2; 
MySQL将尽量使用第二种合并SQL的方式，但在很多情况下，由于研发人员编写的查询采用临时表的方式，因而导致性能 很差。

怎么区分查询视图时用的是第一种还是第二种呢:
可以用EXPLAIN命令来确认，如果EXPLAIN的select_type输出显示DERIVED（查询结果来自一个衍生表），那么查询使用的是临时表的方式(即第一种)

视图里应尽量避免使用GROUP BY、ORDERBY、DISTINCT、聚集函数、UNION和子查询。否则很容易变成第一种方式查询

PS: 视图也是没有索引的。视图可以使用desc的方式查看视图的字段信息，临时表不能，但是临时表可以使用show create table的方式查看
临时表在连接断开时会消失，临时表不会。