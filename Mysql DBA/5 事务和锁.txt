事务（transaction）是作为一个单元的一组具有原子性的有序的数据库操作。

start transaction;
select ...
update ...
insert ...
commit;

这就是一个事务



事务的四个特性
原子性、一致性、隔离性、持久性

下面是官方的定义
原子性：
事务是数据库的逻辑工作单位，事务中包括的所有操作要么都成功执行，要么都失败。

一致性：
事务执行的结果必须是数据库从一个一致性状态变成两一个一致性状态

隔离性：
一个事务的执行不能被其他事务干扰

持久性：
一旦事务成功提交，对数据库中的修改就是持久的。接下来的其他操作或者故障不会对执行结果有影响。


用例子理解：
还是用转账的经典例子，A给B转100块。

需要执行两条操作：
A -100  update account set money=money-100 where name="A";
B +100  update account set money=money+100 where name="B";

这两条操作组成一个事务或者事务单元。

原子性：A -100和B +100 会顺序执行，在这个过程中要么两个操作都成功，只要有一条操作没成功就都失败（回滚）。

一致性：A -100 ~ B +100 这个过程中会出现三个状态：
A 100   B 0     #事务执行前的状态
A 0     B 0     #中间状态
A 0     B 100   #事务执行后的状态

状态1和状态3就是一致性状态，而中间状态我们是看不到的。如果查询的时候，我们如果查到 A=0,B=0 这个中间状态，就违反了一致性。
我们可以通过上锁的方式让中间状态不被查到，在事务操作过程中对A和B记录进行锁定，这样在改变AB记录的时候不能查询A或B记录，这样就不会查到这个中间状态。

所以一致性的实现方式：加锁。
用一句话解释一致性就是：要保证一个事务内所有操作都执行完才可见。

隔离性：A -100 ~ B +100 这个过程中，如果又出现另一个事务 C -100 ~ A +100
那么要等第一个事务完全执行完才能执行第二个事务。因为在事务1的过程中，A和B记录被锁定。如果同时执行事务2，会尝试锁定C和A记录，但由于A已经在事务1时被锁定，只有等待事务1完成，A解除锁定，才能完成事务2。

持久性：举不出例子。


如何在保持事务的逻辑顺序又要求以最快速度完成：
1.排队法
如果有多个事务要进行，我们将其放到队列中串行完成，即一个个按顺序完成，同一时间只完成一个事务操作
如5个事务单元：
a. A -100  B +100 
b. select B
c. C -200 D +200
d. A -100 C +100
e. select C

执行顺序 a-b-c-d-e ，放在一个队列完成

优势：不会有冲突，而且保持一致性
劣势：速度慢
由于是串行的，所以无需使用锁。

2.排他锁（写锁）
加了排他锁，在对某记录进行写的时候，其他客户端就无法对该记录读和写。

所以如果对一条数据a加了排他锁，那么a只能写写串行（客户端1对a的写和客户端2对a的写按先后顺序进行）和写读串行（客户端1对a写和客户端2对a读按先后顺序进行），而不能写写并行和写读并行。

但如果对a,b加了排他锁，客户端1对a写，客户端2对b写，则可以并行。因为a和b是两条不同的数据。

而在数据库会对一个事务中涉及到的所有记录都加上锁。
例如，将 A -100 B +50 C +50 这三个操作放到一个事务1中，则数据库会对ABC同时加上排他锁。

与此同时分别有另外3个客户端进行以下操作：
读A
写C
执行事务 B -100 D +100 
写D

事务1与读A串行
事务1与写C串行
事务1与事务 B -100 D +100 串行
事务1与写D并行

通过这种并行的方式可以加快事务的执行速度。

3.共享锁（读锁）
加了排他锁，对某记录进行读的时候，其他客户端无法对该记录写，但可以读。


总结：
对于同一条数据而言
加排他锁：写写串行，写读串行
加共享锁：读读并行，读写串行

对于两条不同的数据无论加什么锁都是读写，读读，写写，写读都是并行的。


